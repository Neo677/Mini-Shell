
/*
fichier : handle_quotes.c
fonction : ft_strjoin_free
lignes avant : 
free(s1);
free(s2);
lignes changer : 
free(s1);
// free(s2);

Test   5: ❌ echo hello""world 
mini output = (hello world)
bash output = (helloworld)

hello""world doit etre considere comme une string


Test   7: ❌ echo "$PWD" 
mini output = (/home/dpascal/42/100225minishell/Mini-Shell/parsing/minishell_tester )
bash output = (/home/dpascal/42/100225minishell/Mini-Shell/parsing/minishell_tester)

trouver d'ou vient l'espace final

Test  13: ❌ echo "> >> < * ? [ ] | ; [ ] || && ( ) & # $  <<" 
mini output = ()
bash output = (> >> < README.md bash.supp bash_outfiles bonus bonus_bonus builtins extras local.supp loop.out manual_tests mini_outfiles os_specific outfiles pipes redirects syntax test_files tester wildcards ? [ ] | ; [ ] || && ( ) & # $ <<)
mini exit code = 2
bash exit code = 0
mini error = ( syntax error near unexpected token `>')
bash error = ()

"> >> < * ? [ ] | ; [ ] || && ( ) & # $  <<" == string


Test  14: ❌ echo '> >> < * ? [ ] | ; [ ] || && ( ) & # $  <<' 
mini output = ()
bash output = (> >> < README.md bash.supp bash_outfiles bonus bonus_bonus builtins extras local.supp loop.out manual_tests mini_outfiles os_specific outfiles pipes redirects syntax test_files tester wildcards ? [ ] | ; [ ] || && ( ) & # $ <<)
mini exit code = 2
bash exit code = 0
mini error = ( syntax error near unexpected token `>')
bash error = ()

ici '> >> < * ? [ ] | ; [ ] || && ( ) & # $  <<' doit etre reconnu comme une string
* et ? an ne pas gerer ?

Test  15: ❌ echo "exit_code ->$? user ->$USER home -> $HOME" 
mini output = ()
bash output = (exit_code ->0 user ->dpascal home -> /home/dpascal)
mini error = ( invalid environment variable name unexpected end of file)
bash error = ()

ici "exit_code ->$? user ->$USER home -> $HOME" doit etre reconnu comme une string

Test  17: ❌ echo "$" 
mini output = ()
bash output = ($)
mini error = ( syntax error near unexpected token `|' unexpected end of file)
bash error = ()

"$" est considéré comme une erreur avant d'arriver dans l'exec

Test  19: ❌ echo $ 
mini output = ()
bash output = ($)

ici $ ne genere pas d'argument dans la structure t_cmd

Test  21: ❌ echo $?HELLO 
mini output = (0 HELLO)
bash output = (0HELLO)

ici $?HELLO est considéré comme 2 arguments plutot qu'un seul










*/